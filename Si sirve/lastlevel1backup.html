<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Juego</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      margin: 0;
      
    }
  </style>
</head>

<body>
  <button onclick="pauseGame()" class="pause-button">🏠</button>
  <div id="pauseMenu" class="pause-menu hide">
    <button onclick="resumeGame()" id="pausmeMenuButton">Continuar</button>
    <br>
    <button onclick="quitGame()" id="pausmeMenuButton">Salir</button>
  </div>
  <script src="playerScore.js"></script>
  <script src="script.js"></script>

  <button onclick="LoginUsers()" class="login-button">login</button>
  <div id="loginmenu" class="loginmenu hide">
    <button onclick="resumeGame2()" id="pausmeMenuButton">Continuar</button>
    <br>
    <button type="button" id="button-login">Login</button>
    <button type="button" id="button-logout">Logout</button>
  </div>

  <script type="module">
    import * as THREE from "./three.module.js";
    import { OrbitControls } from "./OrbitControls.js";
    import { GLTFLoader } from "./GLTFLoader.js";


    // Import the functions you need from the SDKs you need
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
import { getAuth, signInWithPopup, GoogleAuthProvider, signOut } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js"
import { getDatabase, ref, onValue, set, remove } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-database.js"
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyB6ZBUO4LTlgALjArU3EVAS2QPNYP9HKdg",
  authDomain: "graficasweb-65529.firebaseapp.com",
  databaseURL: "https://graficasweb-65529-default-rtdb.firebaseio.com",
  projectId: "graficasweb-65529",
  storageBucket: "graficasweb-65529.appspot.com",
  messagingSenderId: "758709726020",
  appId: "1:758709726020:web:e69aa24c91f26bad23c511"
};


// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth();
const provider = new GoogleAuthProvider();
const db = getDatabase();

const buttonLogin = document.getElementById("button-login");
const buttonLogout = document.getElementById("button-logout");
let currentUser = {};//puede cambiar a const
//Login
buttonLogin.addEventListener("click", async () => {
  await signInWithPopup(auth, provider)
  .then((result) => {
    // This gives you a Google Access Token. You can use it to access the Google API.
    const credential = GoogleAuthProvider.credentialFromResult(result);
    const token = credential.accessToken;
    console.log("HOLAAA")
    // The signed-in user info.
    currentUser = result.user;
    console.log(currentUser);
    writeUserData(currentUser.uid,0,0,0);
    // IdP data available using getAdditionalUserInfo(result)
    // ...
  }).catch((error) => {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    // ...
  });
})

buttonLogout.addEventListener("click", async()=>{
  signOut(auth).then(() => {
  // Sign-out successful.
  console.log('sign-out successful');
}).catch((error) => {
  console.error("an error happened", error);
});
})

// Limpia la base de datos al cargar la página
function clearDatabase() {
  const dbRef = ref(db, 'jugadores');
  remove(dbRef)
    .then(() => {
      console.log('Base de datos limpiada con éxito.');
    })
    .catch((error) => {
      console.error('Error al limpiar la base de datos:', error);
    });
}

// Llama a la función para limpiar la base de datos al cargar la página
clearDatabase();



    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#566573");

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

            if (soundMuted) {
                console.log("El sonido está silenciado.");
            } else {
                console.log("El sonido está activado.");
            }
         
    const listener = new THREE.AudioListener();
    camera.add(listener);

    const audioLoader = new THREE.AudioLoader;

    const backgroundSound = new THREE.Audio(listener);
    const hitSound = new THREE.Audio(listener);

    audioLoader.load('./background.mp3', function (buffer) {
    backgroundSound.setBuffer(buffer);
    backgroundSound.setLoop(true);
    backgroundSound.play(); // Reproduce el sonido solo si no está silenciado
    });

    audioLoader.load('./hitsound.mp3', function (buffer) {
        hitSound.setBuffer(buffer); 
    });

    document.addEventListener("DOMContentLoaded", function() {
    const isMuted = JSON.parse(localStorage.getItem('soundMuted'));

    if (isMuted) {
        backgroundSound.setVolume(0.0);
        hitSound.setVolume(0.0);
    }else{
      backgroundSound.setVolume(0.1);
        hitSound.setVolume(0.4);
    }
});


    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
    scene.add(hemisphereLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 5, -1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const cameraControl = new OrbitControls(camera, renderer.domElement);

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
      console.log("resize");


    }

    window.addEventListener("resize", resize)
    let mixer;
    let idleAction; // Acción de la pose inicial
    let walkAction; // Acción de la animación de caminar
    let walkBackAction;
    let walkLeftAction;
    let walkRightAction;
    let throwfrancaction;

    /*let mixer2;
    let idleAction2;
    let walkAction2;
    let walkBackAction2;
    let walkLeftAction2;
    let walkRightAction2;
    let throwfrancaction2;
    */

    let objeto;
    let objeto2;
    let character1;
    let pelota;
    let pelota2;


    
    const loaderGLTF = new GLTFLoader();

    function loadModelAndPlayAnimation() {
    
      loaderGLTF.load('./models/yellowcube/cuboamarilloglb.glb', function (modelGLTF) {
        const character2 = modelGLTF.scene;
        scene.add(character2);
        // Posiciona el segundo personaje como desees
        character2.position.set(10, 0, 15);
      });

      loaderGLTF.load('./models/concrete pack/Barrier Block 1/barrera.glb', function (modelGLTF) {
        const barrera = modelGLTF.scene;
        scene.add(barrera);
        barrera.position.set(0, 0, 0);
        barrera.scale.set(2, 2, 2)

      });

      loaderGLTF.load('./models/basket/basketball.glb', function (modelGLTF) {
        const basket = modelGLTF.scene;
        scene.add(basket);
        basket.position.set(0, 0, 0);
        basket.scale.set(4, 1, 6);
      });

      loaderGLTF.load('./models/volleyball/pelota.glb', function (modelGLTF) {
        pelota = modelGLTF.scene;
        scene.add(pelota);
        pelota.position.set(10, 0, -15);
        pelota.scale.set(0.5, 0.5, 0.5);
        pelota.visible = false;
      });

      loaderGLTF.load('./models/volleyball/pelota.glb', function (modelGLTF) {
        pelota2 = modelGLTF.scene;
        scene.add(pelota2);
        pelota2.position.set(10, 0, -15);
        pelota2.scale.set(0.5, 0.5, 0.5);
        pelota2.visible = false;
      });

      
    }

    loadModelAndPlayAnimation();


    //read
  const starCountRef = ref(db, 'jugadores/');
  onValue(starCountRef, (snapshot) => {
    const data = snapshot.val();
    Object.entries(data).forEach(([key, value])=>{
      console.log(`${key} ${value.x} ${value.z} `);

      const jugador = scene.getObjectByName(key);

      if(!jugador){
        loaderGLTF.load('./models/FrankFINALPOSE.glb', function (modelGLTF) {
        objeto = modelGLTF.scene;
        objeto.position.set(value.x, 0, value.z);
        objeto.name = key;
        scene.add(objeto);
        mixer = new THREE.AnimationMixer(objeto);
        const loaderWalk = new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderWalk.load('./models/FrankFINALWALK.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          walkAction = mixer.clipAction(animClip); 
        });

        const loaderBackWalk = new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderBackWalk.load('./models/FRANKWALKBACK.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          walkBackAction = mixer.clipAction(animClip); // Almacena la acción de la animación de caminar
        });

        const loaderSideLWalk = new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderSideLWalk.load('./models/FRANKLEFTWALK.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          walkLeftAction = mixer.clipAction(animClip); 
        });

        const loaderSideRWalk = new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderSideRWalk.load('./models/FRANKRIGHTWALK.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          walkRightAction = mixer.clipAction(animClip); 
        });

        const loaderthrowfrank= new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderthrowfrank.load('./models/FRANKTHROW.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          throwfrancaction = mixer.clipAction(animClip); 
        });

        const loaderidle = new GLTFLoader(); // Nuevo cargador para la animación de caminar
        loaderidle.load('./models/IDLEFRANK.glb', function (animGLTF) {
          const animClip = animGLTF.animations[0];
          idleAction = mixer.clipAction(animClip); // Almacena la acción de la animación de caminar
          idleAction.play(); // Reproducir la animación de caminar de forma predeterminada

          
        });
      });

        
      } else{
        scene.getObjectByName(key).position.x = value.x;
        scene.getObjectByName(key).position.z = value.z;
      }
    });
  });

  function writeUserData(userId, positionX = null, positionZ = null) {
  // Verificar si hay algún valor que actualizar
  if (positionX !== null || positionZ !== null) {
    // Construir el objeto de datos para actualizar
    const dataToUpdate = {};
    if (positionX !== null) dataToUpdate.x = positionX;
    if (positionZ !== null) dataToUpdate.z = positionZ;
   

    // Actualizar los datos en la base de datos solo si hay algo que actualizar
    set(ref(db, 'jugadores/' + userId), dataToUpdate);
  } else {
    console.error('No se proporcionaron valores para actualizar.');
  }
}



// Mantén un registro de qué teclas están siendo presionadas para cada personaje
let player1Keys = {
  w: false,
  s: false,
  a: false,
  d: false,
  g: false
};

/*let player2Keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  m: false
};*/
let score = 0;
document.onkeydown = function (e) {
  const jugadorActual = scene.getObjectByName(currentUser.uid);
  let newScore = score; // Inicializa newScore con el valor actual de score

  if (e.keyCode == 89) { // Verifica si se presionó la tecla 'Y'
  console.log(jugadorActual.position.x);
  jugadorActual.position.x = jugadorActual.position.x - 10; 
    console.log(jugadorActual.position.x);
    newScore + 1; // Incrementa newScore en 1
  }
    writeUserData(currentUser.uid, jugadorActual.position.x, jugadorActual.position.z);

};


// Actualiza las posiciones de los personajes en función de las teclas presionadas
function updateCharactersPositions() {
  const speed = 0.5; // Velocidad del movimiento
  const jugadorActual = scene.getObjectByName(currentUser.uid);
  // Personaje 1
  if (player1Keys.w && mixer && jugadorActual) {
    walkAction.play();
    jugadorActual.position.z += speed;
   
  }
  if (player1Keys.s && mixer && jugadorActual) {
    walkBackAction.play();
    jugadorActual.position.z -= speed;
  }
  if (player1Keys.a && jugadorActual && mixer) {
    walkLeftAction.play();
    jugadorActual.position.x += speed;
  }
  if (player1Keys.d && jugadorActual && mixer) {
    walkRightAction.play();
    jugadorActual.position.x -= speed;
  }
  if (player1Keys.g && jugadorActual && mixer) {
    throwfrancaction.reset(); // Resetea la acción de lanzamiento
    throwfrancaction.setLoop(THREE.LoopOnce); // Establece el modo de bucle para reproducir una vez
    throwfrancaction.play();
    const direction = new THREE.Vector3(0, 0, -1);
    throwBallFromPlayer1(currentUser, direction);
  }

  // Personaje 2
  /*if (player2Keys.ArrowUp && objeto2 && mixer2) {
    walkAction2.play();
    objeto2.position.z -= speed;
  }
  if (player2Keys.ArrowDown && objeto2 && mixer2) {
    walkBackAction2.play();
    objeto2.position.z += speed;
  }
  if (player2Keys.ArrowLeft && objeto2 && mixer2) {
    walkLeftAction2.play();
    objeto2.position.x += speed;
  }
  if (player2Keys.ArrowRight && objeto2 && mixer2) {
    walkRightAction2.play();
    objeto2.position.x -= speed;
  }

  if (player2Keys.m && objeto2 && mixer2) {
    throwfrancaction2.reset(); // Resetea la acción de lanzamiento
    throwfrancaction2.setLoop(THREE.LoopOnce); // Establece el modo de bucle para reproducir una vez
    throwfrancaction2.play();
    const direction = new THREE.Vector3(0, 0, -1);
    throwBallFromPlayer2(objeto2, direction);
  }*/
  //writeUserData(currentUser.uid, null, jugadorActual.position.x, jugadorActual.position.z);
}

// Maneja eventos de teclado para ambos personajes
document.addEventListener("keydown", function (event) {
  // Player 1
  if (event.key in player1Keys) {
    player1Keys[event.key] = true;
  }
  
  // Player 2
  /*if (event.key in player2Keys) {
    player2Keys[event.key] = true;
  }*/
});

document.addEventListener("keyup", function (event) {
  // Player 1
  if (event.key in player1Keys) {
    player1Keys[event.key] = false;
    stopPlayer1Animations();
  }
  
  // Player 2
 /* if (event.key in player2Keys) {
    player2Keys[event.key] = false;
    stopPlayer2Animations();
  }*/
});

// Función para detener las animaciones del Player 1
function stopPlayer1Animations() {
  walkAction.stop();
  walkBackAction.stop();
  walkLeftAction.stop();
  walkRightAction.stop();
}

// Función para detener las animaciones del Player 2
/*
function stopPlayer2Animations() {
  walkAction2.stop();
  walkBackAction2.stop();
  walkLeftAction2.stop();
  walkRightAction2.stop();
}
*/

/*
let avento = false;
let distanceToTravel;

function throwBallFromPlayer1(player, direction) {
    if (player && direction) {
        const startPosition = player.position.clone();
        pelota.position.copy(startPosition);
        pelota.position.y=pelota.position.y+3;
        pelota.visible = true;

        const speed = 2;
        distanceToTravel = 100;
        const deltaZ = -speed;
        const velocity = direction.multiplyScalar(deltaZ);

        function throwBall() {
            if (pelota) {
                pelota.position.add(velocity);
                distanceToTravel -= speed;
                if (distanceToTravel <= 0) {
                    pelota.visible = false;
                    increasePlayer1Score();
                } else {
                    requestAnimationFrame(throwBall);
                }
            }
        }

        throwBall();
    }
}

let avento2 = false;
let distanceToTravel2;

function throwBallFromPlayer2(player, direction) {
    if (player && direction) {
        const startPosition = player.position.clone();
        pelota2.position.copy(startPosition);
        pelota2.position.y=pelota2.position.y+3;
        pelota2.visible = true;

        const speed = 2;
        distanceToTravel2 = 100;
        const deltaZ = +speed;
        const velocity = direction.multiplyScalar(deltaZ);

        function throwBall() {
            if (pelota2) {
                pelota2.position.add(velocity);
                distanceToTravel2 -= speed;
                if (distanceToTravel2 <= 0) {
                    pelota2.visible = false;
                } else {
                    requestAnimationFrame(throwBall);
                }
            }
        }

        throwBall();
    }
}


function checkCollisions() {
    if (pelota  && objeto2) {
        // Obtener las posiciones X y Z de la pelota y el modelo del personaje
        const pelotaX = pelota.position.x;
        const pelotaZ = pelota.position.z;
        const objeto2X = objeto2.position.x;
        const objeto2Z = objeto2.position.z;

        // Definir una distancia mínima para considerar una colisión
        const distanciaMinima = 2; // Ajusta según sea necesario

        // Verificar si la diferencia en las posiciones X y Z está dentro de la distancia mínima
        const distanciaX = Math.abs(pelotaX - objeto2X);
        const distanciaZ = Math.abs(pelotaZ - objeto2Z);

        if (distanciaX < distanciaMinima && distanciaZ < distanciaMinima) {
            // Manejar la colisión aquí
            console.log('¡Colisión detectada con objeto2!');
            hitSound.play();
            increasePlayer1Score();
            pelota.visible = false;
        }
    }

    if (pelota2  && objeto) {
        // Obtener las posiciones X y Z de la pelota y el modelo del personaje
        const pelotaX = pelota2.position.x;
        const pelotaZ = pelota2.position.z;
        const objetoX = objeto.position.x;
        const objetoZ = objeto.position.z;

        // Definir una distancia mínima para considerar una colisión
        const distanciaMinima = 2; // Ajusta según sea necesario

        // Verificar si la diferencia en las posiciones X y Z está dentro de la distancia mínima
        const distanciaX = Math.abs(pelotaX - objetoX);
        const distanciaZ = Math.abs(pelotaZ - objetoZ);

        if (distanciaX < distanciaMinima && distanciaZ < distanciaMinima) {
            // Manejar la colisión aquí
            console.log('¡Colisión detectada con objeto!');
            hitSound.play();
            increasePlayer2Score();
            pelota2.visible = false;
        }
    }
}



const distanceThreshold = 1; 
let distanceToPlayer;

*/

// Llama a esta función en tu bucle de animación
function animate() {
  requestAnimationFrame(animate);
  if (mixer) mixer.update(0.09);
  updateCharactersPositions(); // Actualiza las posiciones de los personajes
 // checkCollisions();
  renderer.render(scene, camera);
}



    animate();
  </script>



</body>

</html>