<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Juego</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <button onclick="pauseGame()" class="pause-button">üè†</button>
  <div id="pauseMenu" class="pause-menu hide">
    <button onclick="resumeGame()" id="pauseMenuButton">Continuar</button>
    <br>
    <button onclick="quitGame()" id="pauseMenuButton">Salir</button>
  </div>
  <script src="playerScore.js"></script>
  <script src="script.js"></script>

  <button onclick="LoginUsers()" class="login-button">login</button>
  <div id="loginmenu" class="loginmenu hide">
    <button onclick="resumeGame2()" id="pauseMenuButton">Continuar</button>
    <br>
    <button type="button" id="button-login">Login</button>
    <button type="button" id="button-logout">Logout</button>
  </div>

  <script type="module">
    import * as THREE from "./three.module.js";
    import { OrbitControls } from "./OrbitControls.js";
    import { GLTFLoader } from "./GLTFLoader.js";

    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
    import { getAuth, signInWithPopup, GoogleAuthProvider, signOut } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js";
    import { getDatabase, ref, onValue, set, remove } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-database.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyB6ZBUO4LTlgALjArU3EVAS2QPNYP9HKdg",
      authDomain: "graficasweb-65529.firebaseapp.com",
      databaseURL: "https://graficasweb-65529-default-rtdb.firebaseio.com",
      projectId: "graficasweb-65529",
      storageBucket: "graficasweb-65529.appspot.com",
      messagingSenderId: "758709726020",
      appId: "1:758709726020:web:e69aa24c91f26bad23c511"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth();
    const provider = new GoogleAuthProvider();
    const db = getDatabase();

    const buttonLogin = document.getElementById("button-login");
    const buttonLogout = document.getElementById("button-logout");
    let currentUser = {};

    // Login
    buttonLogin.addEventListener("click", async () => {
      await signInWithPopup(auth, provider)
        .then((result) => {
          const credential = GoogleAuthProvider.credentialFromResult(result);
          const token = credential.accessToken;
          currentUser = result.user;
          writeUserData(currentUser.uid, 0, 0, 0);
        }).catch((error) => {
          const errorCode = error.code;
          const errorMessage = error.message;
          const email = error.customData.email;
          const credential = GoogleAuthProvider.credentialFromError(error);
        });
    });

    buttonLogout.addEventListener("click", async () => {
      signOut(auth).then(() => {
        console.log('sign-out successful');
      }).catch((error) => {
        console.error("an error happened", error);
      });
    });

    // Limpia la base de datos al cargar la p√°gina
    function clearDatabase() {
      const dbRef = ref(db, 'jugadores');
      remove(dbRef)
        .then(() => {
          console.log('Base de datos limpiada con √©xito.');
        })
        .catch((error) => {
          console.error('Error al limpiar la base de datos:', error);
        });
    }

    clearDatabase();

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#566573");

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight);
    camera.position.set(0, 0, 10);

    const listener = new THREE.AudioListener();
    camera.add(listener);

    const audioLoader = new THREE.AudioLoader();

    const backgroundSound = new THREE.Audio(listener);
    const hitSound = new THREE.Audio(listener);

    audioLoader.load('./background.mp3', function (buffer) {
      backgroundSound.setBuffer(buffer);
      backgroundSound.setLoop(true);
      backgroundSound.play();
    });

    audioLoader.load('./hitsound.mp3', function (buffer) {
      hitSound.setBuffer(buffer);
    });

    document.addEventListener("DOMContentLoaded", function () {
      const isMuted = JSON.parse(localStorage.getItem('soundMuted'));
      if (isMuted) {
        backgroundSound.setVolume(0.0);
        hitSound.setVolume(0.0);
      } else {
        backgroundSound.setVolume(0.1);
        hitSound.setVolume(0.4);
      }
    });

    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
    scene.add(hemisphereLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 5, -1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const cameraControl = new OrbitControls(camera, renderer.domElement);

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
    }

    window.addEventListener("resize", resize);

    let mixer;
    let idleAction, walkAction, walkBackAction, walkLeftAction, walkRightAction, throwfrancaction;
    let pelota, pelota2;

    const loaderGLTF = new GLTFLoader();

    function loadModelAndPlayAnimation() {
      loaderGLTF.load('./models/yellowcube/cuboamarilloglb.glb', function (modelGLTF) {
        const character2 = modelGLTF.scene;
        scene.add(character2);
        character2.position.set(10, 0, 15);
      });

      loaderGLTF.load('./models/concrete pack/Barrier Block 1/barrera.glb', function (modelGLTF) {
        const barrera = modelGLTF.scene;
        scene.add(barrera);
        barrera.position.set(0, 0, 0);
        barrera.scale.set(2, 2, 2);
      });

      loaderGLTF.load('./models/basket/basketball.glb', function (modelGLTF) {
        const basket = modelGLTF.scene;
        scene.add(basket);
        basket.position.set(0, 0, 0);
        basket.scale.set(4, 1, 6);
      });

      loaderGLTF.load('./models/volleyball/pelota.glb', function (modelGLTF) {
        pelota = modelGLTF.scene;
        scene.add(pelota);
        pelota.position.set(10, 0, -15);
        pelota.scale.set(0.5, 0.5, 0.5);
        pelota.visible = false;
      });

      loaderGLTF.load('./models/volleyball/pelota.glb', function (modelGLTF) {
        pelota2 = modelGLTF.scene;
        scene.add(pelota2);
        pelota2.position.set(10, 0, -15);
        pelota2.scale.set(0.5, 0.5, 0.5);
        pelota2.visible = false;
      });


    }

    loadModelAndPlayAnimation();

    const mixers = {};

    function initializeMixer(objeto, playerId) {
      mixer = new THREE.AnimationMixer(objeto);
      mixers[playerId] = mixer;

      objeto.userData.actions = {};

      const loaderWalk = new GLTFLoader();
      loaderWalk.load('./models/FrankFINALWALK.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.walkAction = mixer.clipAction(animClip);
      });

      const loaderBackWalk = new GLTFLoader();
      loaderBackWalk.load('./models/FRANKWALKBACK.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.walkBackAction = mixer.clipAction(animClip);
      });

      const loaderSideLWalk = new GLTFLoader();
      loaderSideLWalk.load('./models/FRANKLEFTWALK.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.walkLeftAction = mixer.clipAction(animClip);
      });

      const loaderSideRWalk = new GLTFLoader();
      loaderSideRWalk.load('./models/FRANKRIGHTWALK.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.walkRightAction = mixer.clipAction(animClip);
      });

      const loaderThrowFrank = new GLTFLoader();
      loaderThrowFrank.load('./models/FRANKTHROW.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.throwfrancaction = mixer.clipAction(animClip);
      });

      const loaderIdle = new GLTFLoader();
      loaderIdle.load('./models/IDLEFRANK.glb', function (animGLTF) {
        const animClip = animGLTF.animations[0];
        objeto.userData.actions.idleAction = mixer.clipAction(animClip);
        objeto.userData.actions.idleAction.play();
      });
    }

    function writeUserData(userId, positionX, positionZ, rotationY) {
      if (positionX !== null || positionZ !== null || rotationY !== null) {
        const dataToUpdate = {
          x: positionX,
          z: positionZ,
          rotationY: rotationY // A√±adimos la rotaci√≥n Y
        };

        set(ref(db, 'jugadores/' + userId), dataToUpdate);
      } else {
        console.error('No se proporcionaron valores para actualizar.');
      }
    }

    const starCountRef = ref(db, 'jugadores/');
    onValue(starCountRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        Object.entries(data).forEach(([key, value]) => {
          const jugador = scene.getObjectByName(key);

          if (!jugador) {
            loaderGLTF.load('./models/FrankFINALPOSE.glb', function (modelGLTF) {
              const objeto = modelGLTF.scene;
              objeto.position.set(value.x, 0, value.z);
              objeto.rotation.y = value.rotationY || 0;
              objeto.name = key;
              scene.add(objeto);
              initializeMixer(objeto, key);
            });
          } else {
            jugador.position.x = value.x;
            jugador.position.z = value.z;
            jugador.rotation.y = value.rotationY || 0;
          }
        });
      }
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      Object.values(mixers).forEach(mixer => mixer.update(delta));
      renderer.render(scene, camera);
    }

    animate();

    const player1Keys = {
      w: false,
      a: false,
      s: false,
      d: false,
      q: false,
      e: false,
      ' ': false,
    };

    document.addEventListener("keydown", function (event) {
      if (event.key in player1Keys) {
        player1Keys[event.key] = true;
      }

      const jugadorActual = scene.getObjectByName(currentUser.uid);
      if (jugadorActual) {
        writeUserData(currentUser.uid, jugadorActual.position.x, jugadorActual.position.z);
      }

      if (event.key === 'g') {
      launchBall();
      }
    });


    function launchBall() {
  const jugadorActual = scene.getObjectByName(currentUser.uid);
  if (jugadorActual && pelota) {
    // Clonar la pelota para no interferir con otras instancias
    const ball = pelota.clone();
    ball.position.copy(jugadorActual.position);
    ball.visible = true;

    const direction = new THREE.Vector3(0, 0, -1); // Direcci√≥n hacia adelante
  //  direction.applyQuaternion(jugadorActual.quaternion); // Aplicar la rotaci√≥n del jugador

    const speed = 0.5; // Velocidad de lanzamiento
    ball.userData.velocity = direction.multiplyScalar(speed);

    scene.add(ball);

    animateBall(ball);
  }
}

function animateBall(ball) {
  function update() {
    ball.position.add(ball.userData.velocity);
    
    // Detectar colisiones con otros jugadores
    const jugadorActual = scene.getObjectByName(currentUser.uid);
    const otherPlayers = scene.children.filter(obj => obj !== jugadorActual && obj.type === 'Group');

    for (const player of otherPlayers) {
      if (ball.position.distanceTo(player.position) < 1) {
        console.log("¬°Le diste!");
        return;
      }
    }

    // Si la pelota se sale de la escena, eliminarla
    if (ball.position.z < -50) {
      scene.remove(ball);
    } else {
      requestAnimationFrame(update);
    }
  }

  update();
}



    document.addEventListener("keyup", function (event) {
      if (event.key in player1Keys) {
        player1Keys[event.key] = false;
      }
    });

    document.onkeydown = function (e) {
      const jugadorActual = scene.getObjectByName(currentUser.uid);

      if (e.keyCode == 89) { // Verifica si se presion√≥ la tecla 'Y'
        console.log(`Posici√≥n antes: ${jugadorActual.position.x}`);
        jugadorActual.position.x = jugadorActual.position.x - 10;
        console.log(`Posici√≥n despu√©s: ${jugadorActual.position.x}`);
        writeUserData(currentUser.uid, jugadorActual.position.x, jugadorActual.position.z);
      }
    };

    function updateCharactersPositions() {
      Object.keys(player1Keys).forEach((key) => {
        const jugadorActual = scene.getObjectByName(currentUser.uid);
        if (!jugadorActual) return;

        const speed = 0.1;
        const actions = jugadorActual.userData.actions;

        if (player1Keys['w']) {
          jugadorActual.position.z += speed;
          if (actions.walkAction) actions.walkAction.play();
        } else if (actions.walkAction) {
          actions.walkAction.stop();
        }
        
        if (player1Keys['a']) {
          jugadorActual.position.x += speed;
          if (actions.walkLeftAction) actions.walkLeftAction.play();
        } else if (actions.walkLeftAction) {
          actions.walkLeftAction.stop();
        }
        
        if (player1Keys['s']) {
          jugadorActual.position.z -= speed;
          if (actions.walkBackAction) actions.walkBackAction.play();
        } else if (actions.walkBackAction) {
          actions.walkBackAction.stop();
        }
        
        if (player1Keys['d']) {
          jugadorActual.position.x -= speed;
          if (actions.walkRightAction) actions.walkRightAction.play();
        } else if (actions.walkRightAction) {
          actions.walkRightAction.stop();
        }

        if (player1Keys['e']) { // Verifica si se presion√≥ la tecla 'E'
          jugadorActual.rotation.y += Math.PI / 2; // Rotar 90 grados (œÄ/2 radianes)
         }

    writeUserData(currentUser.uid, jugadorActual.position.x, jugadorActual.position.z, jugadorActual.rotation.y);
      });
    }

    setInterval(updateCharactersPositions, 100);

  </script>
</body>

</html>
